#!/usr/bin/python3

import sqlite3
from sqlite3 import Error
from pathlib import Path
from subprocess import check_output
import json
import time
import urllib.parse

def profile(p):
    if p == "DTS":
        return "dts"

    if p == "DTS-HD MA":
        return "ma"

    print("Unknown profile: %s" % p)
    return p


def main():
    CLEAR = False
    PLEX_DATABASE_PATH = "/var/lib/plexmediaserver/Library/Application Support/Plex Media Server/Plug-in Support/Databases/com.plexapp.plugins.library.db"
    PATHS = [
       "/data/merged/Movies/",
    ]

    for i, path in enumerate(PATHS):
        PATHS[i] = '(file LIKE "' + path + '%")'
    PATHS = " OR ".join(PATHS)
    return


    try:
        #conn = sqlite3.connect(PLEX_DATABASE_PATH, timeout=30000, isolation_level=None)
        conn = sqlite3.connect(PLEX_DATABASE_PATH, timeout=30000)

        # To-do: It sometimes fails with 'Database locked'. Think about some retry mechanism?
        conn.isolation_level = 'EXCLUSIVE'
        conn.execute('BEGIN EXCLUSIVE')
        cur = conn.cursor()
        cur2 = conn.cursor()

        # To-do: Add our own datatabase, so custom audio metadata isn't completly lost when plex analyses original file
        print("Cleaning up old audio records")
        for (media_stream_id, url) in cur.execute('SELECT `id`, `url` FROM `media_streams` WHERE `index` >= 1000 AND `url` != ""'):
            path = Path(url[7:])

            if CLEAR or not path.exists():
                print("Custom audio file deleted: %s" % url[7:])
                cur2.execute('DELETE FROM `media_streams` WHERE `id` = ? LIMIT 1', (media_stream_id,))

        cur2.close()
        cur.close()
        conn.commit()

        cur = conn.cursor()
        cur2 = conn.cursor()

        # To-do: Make option to scan individual files
        print("Scanning library for new audio")
        for (media_part_id, media_item_id, file) in cur.execute('SELECT id, media_item_id, file FROM media_parts WHERE file != "" AND (' + PATHS + ') AND (file NOT LIKE "%/Trailers/%") ORDER BY file ASC'):
            print("Processing: %s" % file)
            path = Path(file)

            if path.suffix != ".mp4" and path.suffix != ".mkv" and path.suffix != ".avi":
                print("\tFile is not a video.")
                continue

            if not path.exists():
                print("\tFile doesn't exist.")
                continue

            cur2.execute('SELECT MAX(`index`) FROM `media_streams` WHERE `media_item_id` = ? LIMIT 1', (media_item_id,))
            (last_index,) = cur2.fetchone()

            if last_index == None:
                print("\tFile is not yet analysed.")
                continue

            if last_index < 1000:
                last_index = 1000

            base = path.with_suffix('').name + '.'
            base_len = len(base)

            iter = path.parent.iterdir()
            for p in iter:
                if p.suffix != ".mka":
                    continue

                n = p.with_suffix('').name

                if not n.startswith(base):
                    continue

                print("\tFound: %s" % p.name)

                title = ""
                lang = n[base_len:]
                if lang.find(".") != -1:
                    (lang, title) = lang.split('.', 1)

                if title.startswith("track-"):
                    title = ""

                audio_path_absolute = str(p.absolute())
                url = "file://" + audio_path_absolute

                cur2.execute('SELECT id FROM media_streams WHERE url = ? LIMIT 1', (url,))
                res = cur2.fetchone()

                if res != None:
                    print("\t\tAlready in database.")
                    continue

                # Nothing from https://support.plex.tv/articles/203810286-what-media-formats-are-supported/ supports rmvb, so we will use that to force transcoding
                cur2.execute('UPDATE `media_items` SET `container` = "rm" WHERE `id` = ? LIMIT 1', (media_item_id,))

                # ffprobe -hide_banner -loglevel fatal -show_error -show_streams -select_streams a -print_format json -i ""
                media_data = check_output(["ffprobe", "-hide_banner", "-loglevel", "fatal", "-show_error", "-show_streams", "-select_streams", "a", "-print_format", "json", "-i", audio_path_absolute]).decode("utf-8")
                media_data = json.loads(media_data)

                multiple_streams = len(media_data['streams']) > 1

                for media_stream in media_data['streams']:
                    codec = media_stream["codec_name"]

                    if codec == "dts":
                        codec = "dca"
                    #elif codec == "aac":
                    #    codec = "???"

                    extra_data = {}
                    if 'channel_layout' in media_stream:
                        extra_data['ma:audioChannelLayout'] = media_stream['channel_layout']

                    if 'sample_rate' in media_stream:
                        extra_data['ma:samplingRate'] = media_stream['sample_rate']

                    if codec == "dca":
                        if 'bits_per_raw_sample' in media_stream:
                            extra_data['ma:bitDepth'] = media_stream['bits_per_raw_sample']
                        else:
                            extra_data['ma:bitDepth'] = 24

                    if 'profile' in media_stream:
                        extra_data['ma:profile'] = profile(media_stream['profile'])

                    language = 'und'
                    if 'tags' in media_stream:
                        if 'title' in media_stream['tags']:
                            extra_data['ma:title'] = media_stream['tags']['title']
                            print("\t\ttitle: %s" % extra_data['ma:title'])
                        if 'language' in media_stream['tags']:
                            language = media_stream['tags']['language']
                            print("\t\tlanguage: %s" % language)

                    if language != lang and ('tags' not in media_stream or 'language' not in media_stream['tags'] or multiple_streams == False):
                        print("\t\tForcing language: %s" % lang)
                        language = lang

                    if title != "" and ('tags' not in media_stream or 'title' not in media_stream['tags'] or multiple_streams == False):
                        print("\t\tForcing title: %s" % title)
                        extra_data['ma:title'] = title

                    #print(extra_data)
                    extra_data = urllib.parse.urlencode(extra_data)

                    #print(media_stream)

                    bitrate = None
                    if "bit_rate" in media_stream:
                        bitrate = int(media_stream["bit_rate"])

                    date = time.strftime('%Y-%m-%d %H:%M:%S')
                    data = (None, 2, media_item_id, url, codec, language, date, date, last_index, media_part_id, media_stream["channels"], bitrate, media_stream["index"], 0, 0, extra_data,)
                    #print(data)

                    cur2.execute('INSERT INTO `media_streams` (`id`, `stream_type_id`, `media_item_id`, `url`, `codec`, `language`, `created_at`, `updated_at`, `index`, `media_part_id`, `channels`, `bitrate`, `url_index`, `default`, `forced`, `extra_data`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);', data)
                    cur2.execute('SELECT `metadata_item_id` FROM `media_items` WHERE `id` = ? LIMIT 1', (media_item_id,))
                    (metadata_item_id,) = cur2.fetchone()
                    cur2.execute('UPDATE `metadata_items` SET `added_at`=? WHERE `id`=?', (date, metadata_item_id,))

                    last_index = last_index + 1

        cur.close()
        cur2.close()
        conn.commit()
        conn.close()
    except Error as e:
        print(e)


if __name__ == '__main__':
    main()
